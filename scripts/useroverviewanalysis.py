# -*- coding: utf-8 -*-
"""UserOverviewAnalysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I3mDv95t0u0HQA_svNcy24Kh3xxTHwCx

## Module Imports
"""

import pandas as pd
import numpy as np
from sklearn import preprocessing
from sklearn.preprocessing import Normalizer
from sklearn.preprocessing import MinMaxScaler
from matplotlib import pyplot as plt
import seaborn as sns

"""### Mount Google Drive to Google Colab"""

from google.colab import drive
drive.mount('/content/drive')

"""# Data Understanding

### **Identify datasets with NaN or None values**
"""

import warnings
warnings.filterwarnings('ignore')
pd.set_option('max_column', None)
db = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/data/Week1_challenge_data_source(CSV).csv', na_values=['undefined','?', None])
db.head() # the fisrt five rows

"""# Size of the dataset
### Columns of the dataset
"""

# list of column  names
db.columns.tolist()

"""### Number of columns"""

print(f"Number of columns: ", len(db.columns))

"""### Number of data points and data size"""

print(f" There are {db.shape[0]} rows and {db.shape[1]} columns")

"""### Features/columns and their data type"""

db.dtypes

"""##Missing values percentile"""

# how many missing values exist or better still what is the % of missing values in the dataset?
def percent_missing(df):

    # Calculate total number of cells in dataframe
    totalCells = np.product(df.shape)

    # Count number of missing values per column
    missingCount = df.isnull().sum()

    # Calculate total number of missing values
    totalMissing = missingCount.sum()

    # Calculate percentage of missing values
    print("The dataset contains", round(((totalMissing/totalCells) * 100), 3), "%", "missing values.")

percent_missing(db)

"""### Columns with missing values count

The Column "Nb of sec with 37500B < Vol UL" has maximum missing values of 130254 occurances
"""

db.isna().sum() # missing values of each column

print ("Maximum missing values per column: ", np.max(db.isna().sum())) # print(db.isna().sum().max())

"""### Maximum values of each column"""

db.max()

"""### Top 10 Handsets used"""

db_hndset_count = db['Handset Type'].value_counts()
top_10_hndsets = db_hndset_count.head(10)
print("Most used handset types in Descending order:\n", db_hndset_count)
print("\n\nTop 10 handsets used: \n", top_10_hndsets)

"""### Top 3 handset manufacturers"""

db_hndset_manufac_count = db['Handset Manufacturer'].value_counts()
top_3_manufact = db_hndset_manufac_count.head(3)
print("Dominant manufacturers in descending order:\n", db_hndset_manufac_count)
print("\n\nTop 3 manufacturers: \n", top_3_manufact)

"""### Manufacturer-Handset pairs"""

db_hndset_manufac_pair = db.value_counts(["Handset Manufacturer", "Handset Type"])
top_3_manufact_5_hndset = db_hndset_manufac_pair.head(3)
print("Manufacturers-handset pair:\n", top_3_manufact_5_hndset)
# print("\n\nTop 3 manufacturers: \n", top_3_manufact)
# db_manufac_hndset = db.groupby("Handset Manufacturer", "Handset Type")

"""### Data Aggregation with each column"""

db['Bearer Id'].value_counts() # Each BearerID occurances aggregated
# db.value_counts('Bearer Id') also works

"""### User (IMEI) Grouped and Agregated with Bearer Id(xDR session)"""

# db_user_xDR = db.groupby(["IMEI","Bearer Id"]).agg(session_count = ('Bearer Id', 'value_counts')) # it also works
db_user_xDR = db.groupby(["IMEI","Bearer Id"]).size()
db_user_xDR

"""### User(IMEI) Grouped and Aggregated with session duration"""

# db_user_Duration = db.groupby(["IMEI","Dur. (ms)"]).size()
# db_user_Duration = pd.pivot_table(db, values = "Dur. (ms)",index=["IMEI"],aggfunc=np.sum)
db_user_Duration = db.groupby(["IMEI","Dur. (ms)"]).size() #transform(sum)
db_user_Duration

"""### User(IMEI) and Total UL(Upload) Grouped and Aggregated"""

db_user_UL_data = db.groupby(["IMEI","Total UL (Bytes)"]).size()
db_user_UL_data

"""### User(IMEI) and total download(DL) grouped and aggregated"""

db_user_DL_data = db.groupby(["IMEI","Total DL (Bytes)"]).size()
db_user_DL_data

"""### Data Volume for Social Media DL (Bytes)"""

db_user_DL_social_media = db.groupby(["IMEI","Social Media DL (Bytes)"]).size()
db_user_DL_social_media

"""### Data volume for Social Media UL (Bytes)"""

db_user_UL_social_media = db.groupby(["IMEI","Social Media UL (Bytes)"]).size()
db_user_UL_social_media

"""### Data volume for YouTube DL (Bytes)"""

db_user_DL_Youtube = db.groupby(["IMEI","Youtube DL (Bytes)"]).size()
db_user_DL_Youtube

"""### Data volume for YouTube UL (Bytes)"""

db_user_UL_Youtube = db.groupby(["IMEI","Youtube UL (Bytes)"]).size()
db_user_UL_Youtube

"""### Data volume for Netflix DL (Bytes)"""

db_user_DL_Netflix = db.groupby(["IMEI","Netflix DL (Bytes)"]).size()
db_user_DL_Netflix

"""### Data volume for Netflix UL (Bytes)"""

db_user_UL_Netflix = db.groupby(["IMEI","Netflix UL (Bytes)"]).size()
db_user_UL_Netflix

"""### Data volume for Google DL (Bytes)"""

db_user_DL_Google = db.groupby(["IMEI","Google DL (Bytes)"]).size()
db_user_DL_Google

"""### Data volume for Google UL (Bytes)"""

db_user_UL_Google = db.groupby(["IMEI","Google UL (Bytes)"]).size()
db_user_UL_Google

"""### Data volume for Email DL (Bytes)"""

db_user_DL_Email = db.groupby(["IMEI","Email DL (Bytes)"]).size()
db_user_DL_Email

"""### Data volume for Email UL (Bytes)"""

db_user_UL_Email = db.groupby(["IMEI","Email UL (Bytes)"]).size()
db_user_UL_Email

"""### Data volume for Gaming DL (Bytes)"""

db_user_DL_Gaming = db.groupby(["IMEI","Gaming DL (Bytes)"]).size()
db_user_DL_Gaming

"""### Data volume for Gaming UL (Bytes)"""

db_user_UL_Gaming = db.groupby(["IMEI","Gaming UL (Bytes)"]).size()
db_user_UL_Gaming

"""### Data volume for Other DL"""

db_user_DL_Other = db.groupby(["IMEI","Other DL (Bytes)"]).size()
db_user_DL_Other

"""### Data Volume for Other UL"""

db_user_UL_Other = db.groupby(["IMEI","Other UL (Bytes)"]).size()
db_user_UL_Other

"""# Data Exploration

Use Mode method to fill the missing datapoints of all 'object' type features and Mean/Median methods for all numuric type features.
*   use Median method for skewed(negative/positive) numeric feature and 
*   use MEAN/Median for non-skewd/symetrical numeric feature

### Method selection based on data skewness
"""

db.skew(axis=0)

"""### Skewness visualization with histogram"""

db['Total UL (Bytes)'].hist()

db['Total DL (Bytes)'].hist()

db['Total UL (Bytes)'].hist()

"""### Positively skewed parameter"""

db['HTTP DL (Bytes)'].hist()

"""### Negatively skewwed parameter

"""

db['UL TP < 10 Kbps (%)'].hist()

"""### Data with sum of missing values in each column - revisited"""

db.isna().sum()

"""### Column data types - revisited"""

db.dtypes

"""### Utility function to fill missing values
* numeric missing values with mean method
* object type missing values with mode method
"""

# fill numeric columns with ffill and bfill
"""
df[col].fillna(method='ffill') and df[col].fillna(method='bfill') or 
df[col].ffill(axis = 0) and df[col].bfill(axis = 0) fills the missing values with the value before/after it
"""
# fill missing numeric values with mean and object type values with mode
def fill_missing_values(df):
  for column in df.columns:
    if df[column].dtype == 'float64':
      df[column] = df[column].fillna(df[column].mean())
    elif df[column].dtypes == 'object':
      df[column] = df[column].fillna(df[column].mode()[0])
  return df

"""### Data with all missing values filled - zero null count


"""

fill_missing_values(db).isna().sum()

"""### Other method of handling missing values - Interpolation
* We can use interpolation while working with time-series data because in time-series data we like to fill missing values with previous one or two values.
* It can be used to estimate unknown data points between two known data points.

##### Since we are not considering the time-series nature of the telecom data, we choose not to use interpolation here.
"""

# db.interpolate(inplace=True)

"""## Transforming Data

**Scaling and Normalization**

##### Scaling - changing the range of your data 
##### Normalization, you're changing the shape of the distribution of your data.

#### Scaling

* This transforms data so that it fits within a specific scale, like 0-100 or 0-1. 
* It is important when we're using methods based on distance measures of data points like support vector machines (SVM) or k-nearest neighbors (KNN).
* We use the scaler method from sklearn.

#### Normalization

Scaling just changes the range of your data. Normalization is a more radical transformation. The point of normalization is to change your observations so that they can be described as a normal distribution.

* Normal distribution ("bell curve", Gaussian distribution) is a specific statistical distribution where a roughly equal observations fall above and below the mean
 * The mean and the median are the same, and there are more observations closer to the mean.

* In general, you'll normalize your data if you're going to be using a machine learning or statistics technique like LDA and Gaussian naive Bayes that assumes your data is normally distributed. Some examples of these include linear discriminant analysis (LDA) and Gaussian naive Bayes. (Pro tip: any method with "Gaussian" in the name probably assumes normality.)

* We usee the Normalizer method from sklearn

### Numeric value scalling
"""

minmax_scaler = preprocessing.MinMaxScaler()
def scalling_numeric_values(df):
  col_values = []
  for column in df.columns:
    if df[column].dtype == 'float64':
      col_values.append(list(df[column].values))
  col_values_skaled = minmax_scaler.fit_transform(col_values)
  db_scaled = pd.DataFrame(col_values_skaled)
  return df

db_sklearn = fill_missing_values(db.copy())
scalling_numeric_values(db_sklearn)

"""### Scaling between [0,1]"""

def scalling_numeric_values_0_1(df):
  for column in df.columns:
    if df[column].dtype == 'float64':
      df[column] = MinMaxScaler().fit_transform(np.array(df[column]).reshape(150001,1))
  return df

db_sklearn = fill_missing_values(db.copy())
scalling_numeric_values_0_1(db_sklearn)

"""### Min values in each column"""

db.min()

"""### Max values in each column"""

db.max()

"""### Difference between min and max values in each column"""

# db.max() - db.min()

def plotting_count(df):
  num = df.select_dtypes(include=np.number)  # Get numeric columns
  n = num.shape[1] # Number of cols

  fig, axes = plt.subplots(5, 1, figsize=(12/2.54, 12/2.54))  # create subplots

  for ax, col in zip(axes, num):  # For each column...
      sns.distplot(num[col], ax=ax)   # Plot histogram
      ax.axvline(num[col].mean(), c='k')  # Plot mean

plotting_count(db)

db.head().plot(x="Dur. (ms)", y=["Total UL (Bytes)", "Total DL (Bytes)"],
        kind="line", figsize=(10, 6))

# db.head().plot()

def normalizer(df, col):
    # norm = Normalizer()
    # # normalize the exponential data with boxcox
    # normalized_data = norm.fit_transform(df)
    # # plot both together to compare
    # fig, ax=plt.subplots(1,2, figsize=(10, 6))
    # sns.histplot(df, ax=ax[0])
    # ax[0].set_title("Original Data")
    # sns.histplot(normalized_data[0], ax=ax[1])
    # ax[1].set_title("Normalized data")
    df[col].plot()

db_num=db_sklearn.select_dtypes(include=np.number)
# db_num
normalizer(db_num, "Dur. (ms)")

# check datatypes
db.info()

# df_clean.info()

# df_clean['fix_age'].unique()

# df_clean['age'] = [ ((int(i.split('-')[0]) + int(i.split('-')[1])) / 2)  for i in df_clean['fix_age']]

"""## Utility Functions"""

# # Function to calculate missing values by column
# def missing_values_table(df):
#     # Total missing values
#     mis_val = df.isnull().sum()

#     # Percentage of missing values
#     mis_val_percent = 100 * df.isnull().sum() / len(df)

#     # dtype of missing values
#     mis_val_dtype = df.dtypes

#     # Make a table with the results
#     mis_val_table = pd.concat([mis_val, mis_val_percent, mis_val_dtype], axis=1)

#     # Rename the columns
#     mis_val_table_ren_columns = mis_val_table.rename(
#     columns = {0 : 'Missing Values', 1 : '% of Total Values', 2: 'Dtype'})

#     # Sort the table by percentage of missing descending
#     mis_val_table_ren_columns = mis_val_table_ren_columns[
#         mis_val_table_ren_columns.iloc[:,1] != 0].sort_values(
#     '% of Total Values', ascending=False).round(1)

#     # Print some summary information
#     print ("Your selected dataframe has " + str(df.shape[1]) + " columns.\n"      
#         "There are " + str(mis_val_table_ren_columns.shape[0]) +
#           " columns that have missing values.")

#     # Return the dataframe with missing information
#     return mis_val_table_ren_columns

# def format_float(value):
#     return f'{value:,.2f}'

# def find_agg(df:pd.DataFrame, agg_column:str, agg_metric:str, col_name:str, top:int, order=False )->pd.DataFrame:
    
#     new_df = df.groupby(agg_column)[agg_column].agg(agg_metric).reset_index(name=col_name).\
#                         sort_values(by=col_name, ascending=order)[:top]
    
#     return new_df

# def convert_bytes_to_megabytes(df, bytes_data):
#     """
#         This function takes the dataframe and the column which has the bytes values
#         returns the megabytesof that value
        
#         Args:
#         -----
#         df: dataframe
#         bytes_data: column with bytes values
        
#         Returns:
#         --------
#         A series
#     """
    
#     megabyte = 1*10e+5
#     df[bytes_data] = df[bytes_data] / megabyte
    
#     return df[bytes_data]

# pd.options.display.float_format = format_float

"""## Extracting Data"""

# db['readmitted'].value_counts()

# percent_missing(df_clean)

# missing_values_table(df_clean)

# def map_readmitted(col):
#     readmitted_map = {'NO' : 'NO', '>30': 'YES', '<30': 'YES'}
#     return col.map(readmitted_map)
# # 
# db['fix_readmitted'] = map_readmitted(db['readmitted'])

# unique encounter id
# db['change'].unique()

# db.shape

# pd.set_option('max_column', None)
# df = pd.read_excel("/content/drive/Shareddrives/10 Academy/Intensive training/Batch 6/Content-B6/Week-1/data/Week1_challenge_data_source.xlsx", engine = 'openpyxl')
# df.head()

"""### Mean and Mediam of some vital attributes"""

columns = ['Social Media DL (Bytes)', 'Social Media UL (Bytes)',
           'Google DL (Bytes)', 'Google UL (Bytes)','Total UL (Bytes)', 'Total DL (Bytes)']
db[columns].mean()

db[columns].median()

"""### Univariate analysis"""

import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
sns.set_style('darkgrid')
sns.set(font_scale=1.3)

"""### Non-graphical Univariat EDA"""

db.describe()

db.info()

db.isna().sum()

db.isnull().sum()

"""### Graphical Univariate EDA"""

sns.histplot(x=columns[0], data =db)

sns.histplot(x=columns[1], data =db)

sns.histplot(x=db[columns]['Total UL (Bytes)'], data =db)

sns.histplot(x=db[columns]['Total DL (Bytes)'], data =db)

"""### Bivariate analysis

# NB: The pivot_table() method took me too long to return the plot

---
"""

# pd.pivot_table(db,columns =['Total DL (Bytes)','Social Media DL (Bytes)'])#,aggfunc=[np.sum])

sns.regplot(x='Total DL (Bytes)',y='Social Media DL (Bytes)',data=db)
# sns.countplot(x='Total DL (Bytes)',data=db) 
#boxplot, violinplot, stripplot, swarmplot, barplot also works

"""### Correlation Analysis"""

# db['Total UL (Bytes)'].corr(method='pearson')
db.corr(method='pearson')

